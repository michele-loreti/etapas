/*
 * generated by Xtext
 */
package org.cmg.tapas.xtext.slts.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.cmg.tapas.xtext.slts.simpleLts.Model
import org.cmg.tapas.TAPAsProjectHelper
import org.cmg.tapas.xtext.slts.simpleLts.Action
import org.cmg.tapas.xtext.slts.simpleLts.State
import org.cmg.tapas.xtext.slts.simpleLts.Label
import org.cmg.tapas.xtext.slts.simpleLts.Formula
import org.cmg.tapas.xtext.slts.simpleLts.HmlFormula
import org.cmg.tapas.xtext.slts.simpleLts.HmlOrFormula
import org.cmg.tapas.xtext.slts.simpleLts.HmlAndFormula
import org.cmg.tapas.xtext.slts.simpleLts.HmlNotFormula
import org.cmg.tapas.xtext.slts.simpleLts.HmlDiamondFormula
import org.cmg.tapas.xtext.slts.simpleLts.HmlBoxFormula
import org.cmg.tapas.xtext.slts.simpleLts.HmlMinFixPoint
import org.cmg.tapas.xtext.slts.simpleLts.HmlMaxFixPoint
import org.cmg.tapas.xtext.slts.simpleLts.HmlTrue
import org.cmg.tapas.xtext.slts.simpleLts.HmlFalse
import org.cmg.tapas.xtext.slts.simpleLts.HmlPredicate
import org.cmg.tapas.xtext.slts.simpleLts.HmlRecursionVariable
import org.cmg.tapas.xtext.slts.simpleLts.LabelPredicate
import org.cmg.tapas.xtext.slts.simpleLts.CupLabelPredicate
import org.cmg.tapas.xtext.slts.simpleLts.CapLabelPredicate
import org.cmg.tapas.xtext.slts.simpleLts.NotLabelPredicate
import org.cmg.tapas.xtext.slts.simpleLts.AnyLabelPredicate
import org.cmg.tapas.xtext.slts.simpleLts.ActionLabelPredicate
import org.cmg.tapas.xtext.slts.simpleLts.HmlFormulaDeclaration
import org.cmg.tapas.xtext.slts.simpleLts.LtlFormulaDeclaration
import org.cmg.tapas.xtext.slts.simpleLts.LtlFormula
import org.cmg.tapas.xtext.slts.simpleLts.LtlOrFormula
import org.cmg.tapas.xtext.slts.simpleLts.LtlAndFormula
import org.cmg.tapas.xtext.slts.simpleLts.LtlUntilFormula
import org.cmg.tapas.xtext.slts.simpleLts.LtlNextFormula
import org.cmg.tapas.xtext.slts.simpleLts.LtlNotFormula
import org.cmg.tapas.xtext.slts.simpleLts.LtlTrue
import org.cmg.tapas.xtext.slts.simpleLts.LtlFalse
import org.cmg.tapas.xtext.slts.simpleLts.LtlAtomicProposition
import org.cmg.tapas.xtext.slts.simpleLts.LtlAlwaysFormula
import org.cmg.tapas.xtext.slts.simpleLts.LtlEventuallyFormula

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class SimpleLtsGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for( m: resource.allContents.toIterable.filter(typeof(Model)) ) {
			println(resource.URI)
			print("Is relative: ")
			println(resource.URI.relative)
			print("Is file: ")
			println(resource.URI.file)
			print("Is hierarchical: ")
			println(resource.URI.hierarchical)
			print("Path: ")
			println(resource.URI.path)
			print("Is platform: ")
			println(resource.URI.platform)
			print("To platform (true): ")
			println(resource.URI.toPlatformString(true))
			print("To platform (false): ")
			println(resource.URI.toPlatformString(false))
			print("Package folder: ")
			println(TAPAsProjectHelper.getPackageFolder(resource))
			fsa.generateFile(
				TAPAsProjectHelper.getPackageFolder(resource)+"/"+m.name+".java",
				m.generateSpecificationClass(
					TAPAsProjectHelper.getPackageFolder(resource).replace('/','.')
				)
			);			
		}
	}
	
	
	def generateSpecificationClass( Model m , String pack ) {
		'''
		package «pack»;
		
		import org.cmg.tapas.core.util.*;
		import org.cmg.tapas.formulae.actl.*;
		import org.cmg.tapas.formulae.actl.path.*;
		import org.cmg.tapas.formulae.actl.state.*;
		import org.cmg.tapas.slts.runtime.*;
		import org.cmg.tapas.formulae.ltl.*;
		import org.cmg.tapas.formulae.ltl.LtlFormula.Atomic;
		import org.cmg.tapas.formulae.hml.*;
		import org.cmg.tapas.formulae.hml.HmlAtomic;
		import org.cmg.tapas.core.graph.filter.*;
		import java.util.*;
		

		public class «m.name» extends SltsModule {

			
			protected void initActions() {
				«FOR a:m.elements.filter(typeof(Action))»
				addAction( new SltsAction( "«a.name»" ) );
				«ENDFOR»
			}
			
			protected void initFormulae() {
				«FOR f:m.elements.filter(typeof(HmlFormulaDeclaration))»
				addFormula( "«f.name»" , generate_HMLFORMULA_«f.name»() );
				«ENDFOR»
				«FOR f:m.elements.filter(typeof(LtlFormulaDeclaration))»
				addFormula( "«f.name»" , generate_LTLFORMULA_«f.name»() );
				«ENDFOR»
			}
			
			«FOR f:m.elements.filter(typeof(HmlFormulaDeclaration))»
			«f.formulaDeclaration»	
			«ENDFOR»
			
			«FOR f:m.elements.filter(typeof(LtlFormulaDeclaration))»
			«f.formulaDeclaration»	
			«ENDFOR»

			protected void initLabels() {
				«FOR l:m.elements.filter(typeof(Label))»
				addLabel( "«l.name»" , «FOR s:l.states SEPARATOR ','» "«s.name»" «ENDFOR»); 
				«ENDFOR»
			}
		
			protected void initStateSpace() {
				«FOR s:m.elements.filter(typeof(State))»
				SltsState _state_«s.name» = new SltsState( "«s.name»" );				
				addState( _state_«s.name» );
				«ENDFOR»

				«FOR s:m.elements.filter(typeof(State))»
				//Rules for state: «s.name»
				«FOR r:s.rules»
				_state_«s.name».addNext( getAction( "«r.action.name»" ) , _state_«r.next.name» ); 	
				«ENDFOR»
				«ENDFOR»
				
			}
					
										
		}
				
		'''				
	}

	def getFormulaDeclaration( HmlFormulaDeclaration formula ) {
		'''

		protected HmlFormula<SltsState,SltsAction> generate_HMLFORMULA_«formula.name»() {
				«formula.formula.generateDeclarationsOfRecursiveFormulae»				
				«formula.formula.generatePopulationOfRecursiveFormulae»
				return «formula.formula.generateHmlFormulaeCode»;
		}
		
		'''		
	}
	
	def CharSequence generateDeclarationsOfRecursiveFormulae( HmlFormula f ) {
		switch f {
			HmlOrFormula: {
				'''
				«f.left.generateDeclarationsOfRecursiveFormulae»
				«f.right.generateDeclarationsOfRecursiveFormulae»
				'''
			}
			HmlAndFormula: {
				'''
				«f.left.generateDeclarationsOfRecursiveFormulae»
				«f.right.generateDeclarationsOfRecursiveFormulae»
				'''
			}
			HmlNotFormula: {
				f.arg.generateDeclarationsOfRecursiveFormulae
			}
			HmlDiamondFormula:
				f.arg.generateDeclarationsOfRecursiveFormulae
			HmlBoxFormula:
				f.arg.generateDeclarationsOfRecursiveFormulae
			HmlMinFixPoint:
				'''
				HmlFixPoint<SltsState, SltsAction> _FIX_«f.name» = new HmlFixPoint<SltsState, SltsAction>(false, "«f.name»");
				'''
			HmlMaxFixPoint:
				'''
				HmlFixPoint<SltsState, SltsAction> _FIX_«f.name» = new HmlFixPoint<SltsState, SltsAction>(true, "«f.name»");
				'''
			HmlTrue: ''''''
			HmlFalse: ''''''
			HmlPredicate: ''''''
			default:
				''''''
		}
	}
	
	def CharSequence generatePopulationOfRecursiveFormulae( HmlFormula f ) {
		switch f {
			HmlOrFormula: {
				'''
				«f.left.generatePopulationOfRecursiveFormulae»
				«f.right.generatePopulationOfRecursiveFormulae»
				'''
			}
			HmlAndFormula: {
				'''
				«f.left.generatePopulationOfRecursiveFormulae»
				«f.right.generatePopulationOfRecursiveFormulae»
				'''
			}
			HmlNotFormula: {
				f.arg.generatePopulationOfRecursiveFormulae
			}
			HmlDiamondFormula:
				f.arg.generatePopulationOfRecursiveFormulae
			HmlBoxFormula:
				f.arg.generatePopulationOfRecursiveFormulae
			HmlMinFixPoint:
				'''
				_FIX_«f.name».setSubformula( «f.arg.generateHmlFormulaeCode»); 
				«f.arg.generatePopulationOfRecursiveFormulae»
				'''
			HmlMaxFixPoint:
				'''
				_FIX_«f.name».setSubformula( «f.arg.generateHmlFormulaeCode»); 
				«f.arg.generatePopulationOfRecursiveFormulae»
				'''
			HmlTrue: ''''''
			HmlFalse: ''''''
			default:
				''''''
		}
	}

	def CharSequence generateHmlFormulaeCode( HmlFormula f ) {
		switch f {
			HmlOrFormula: {
				'''
				new HmlOrFormula<SltsState, SltsAction>( 
					«f.left.generateHmlFormulaeCode» , 
					«f.right.generateHmlFormulaeCode»  
				)
				'''
			}
			HmlAndFormula: {
				'''
				new HmlAndFormula<SltsState, SltsAction>( 
					«f.left.generateHmlFormulaeCode» , 
					«f.right.generateHmlFormulaeCode»  
				)
				'''
			}
			HmlNotFormula: {
				'''
				new HmlNotFormula<SltsState, SltsActions>(
					«f.arg.generateHmlFormulaeCode»
				)
				'''
			}
			HmlDiamondFormula:
				'''
				new HmlDiamondFormula<SltsState,SltsAction>( 
						«f.action.generateFilterCode» , 
						«f.arg.generateHmlFormulaeCode»
				)
				'''
			HmlBoxFormula:
				'''
				new HmlBoxFormula<SltsState,SltsAction>( 
						«f.action.generateFilterCode» , 
						«f.arg.generateHmlFormulaeCode»
				)
				'''
			HmlMinFixPoint:
				'''
				_FIX_«f.name»
				'''
			HmlMaxFixPoint:
				'''
				_FIX_«f.name»
				'''
			HmlRecursionVariable:
				'''
				_FIX_«f.refeerence.name».getReference()
				'''
			HmlTrue: '''new HmlTrue<SltsState,SltsAction>()'''
			HmlFalse: '''new HmlFalse<SltsState,SltsAction>()'''
			HmlPredicate:'''new HmlAtomic<SltsState,SltsAction>(getLabel("«f.label.name»"))'''
			default:
				'''new HmlFalse<SltsState,SltsAction>()'''
		}
	}
	
	def getFormulaDeclaration( LtlFormulaDeclaration formula ) {
		'''

		protected LtlFormula<SltsState> generate_LTLFORMULA_«formula.name»() {
				return «formula.formula.generateLtlFormulaeCode»;
		}
		
		'''		
	}
	
	def CharSequence generateLtlFormulaeCode( LtlFormula f ) {
		switch f{
			LtlOrFormula : {
				'''
				new LtlFormula.Or<SltsState>(
				«f.left.generateLtlFormulaeCode» ,
				«f.right.generateLtlFormulaeCode»
				)
				'''
			}
			LtlAndFormula : {
				'''
				new LtlFormula.And<SltsState>(
				«f.left.generateLtlFormulaeCode» ,
				«f.right.generateLtlFormulaeCode»
				)
				'''
			}
			LtlUntilFormula : {
				'''
				new LtlFormula.Until<SltsState>(
				«f.left.generateLtlFormulaeCode» ,
				«f.right.generateLtlFormulaeCode»
				)
				'''
			}
			LtlNextFormula : {
				'''
				new LtlFormula.Next<SltsState>(
				«f.arg.generateLtlFormulaeCode»
				)
				'''
			}
			LtlAlwaysFormula : {
				'''
				new LtlFormula.Not<SltsState>(
					new LtlFormula.Until<SltsState>(
					new LtlFormula.True<SltsState>() , 
					new LtlFormula.Not<SltsState>(«f.arg.generateLtlFormulaeCode»))
					)
				'''
			}
			LtlEventuallyFormula : {
				'''
				new LtlFormula.Until<SltsState>(
					new LtlFormula.True<SltsState>() , «f.arg.generateLtlFormulaeCode»)
				'''
			}
			LtlNotFormula : {
				'''
				new LtlFormula.Not<SltsState>(
				«f.arg.generateLtlFormulaeCode»
				)
				'''
			}
			LtlTrue : ''' new LtlFormula.True<SltsState>()'''
			LtlFalse : ''' new LtlFormula.False<SltsState>()'''
			LtlAtomicProposition:'''new LtlFormula.Atomic<SltsState>("«f.prop.name»" , getLabel("«f.prop.name»"))'''
			default:
				'''new LtlFormula.False<SltsState>()'''
		}
	}

	
	def CharSequence generateFilterCode( LabelPredicate pred ) {
		switch pred {
			CupLabelPredicate: 
				'''new OrFilter<SltsAction>( «pred.left.generateFilterCode» , «pred.righ.generateFilterCode»)'''	
			CapLabelPredicate:
				'''new AndFilter<SltsAction>( «pred.left.generateFilterCode» , «pred.right.generateFilterCode»)'''	
			NotLabelPredicate:
				'''new NotFilter<SltsAction>( «pred.arg.generateFilterCode» )'''	
			AnyLabelPredicate:
				'''new TrueFilter<SltsAction>() '''
			ActionLabelPredicate:
				'''new SingleActionFilter<SltsAction>( getAction("«pred.act.name»") )'''
			default:
				'''new FalseFilter<SltsAction>( )'''
		}
	}
}
