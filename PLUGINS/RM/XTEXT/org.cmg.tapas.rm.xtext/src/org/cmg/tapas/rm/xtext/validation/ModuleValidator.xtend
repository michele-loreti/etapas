/*
 * generated by Xtext
 */
package org.cmg.tapas.rm.xtext.validation

import org.eclipse.xtext.validation.Check
import org.cmg.tapas.rm.xtext.module.Plus
import com.google.inject.Inject
import org.cmg.tapas.rm.xtext.module.ModulePackage
import org.cmg.tapas.rm.xtext.module.Minus
import org.cmg.tapas.rm.xtext.module.Multiplication
import org.cmg.tapas.rm.xtext.module.Division
import org.cmg.tapas.rm.xtext.module.Or
import org.cmg.tapas.rm.xtext.module.And
import org.cmg.tapas.rm.xtext.module.NotExpression
import org.cmg.tapas.rm.xtext.module.Equal
import org.cmg.tapas.rm.xtext.module.NotEqual
import org.cmg.tapas.rm.xtext.module.LessEq
import org.cmg.tapas.rm.xtext.module.GreaterEq
import org.cmg.tapas.rm.xtext.module.Less
import org.cmg.tapas.rm.xtext.module.Greater
import org.cmg.tapas.rm.xtext.module.Command

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.cmg.tapas.rm.xtext.RModuleUtil.*
import org.cmg.tapas.rm.xtext.module.Module
import org.cmg.tapas.rm.xtext.module.Rule
import org.cmg.tapas.rm.xtext.module.Function
import org.cmg.tapas.rm.xtext.module.Constant
import org.cmg.tapas.rm.xtext.module.Variable
import org.cmg.tapas.rm.xtext.module.LiteralExpression
import org.cmg.tapas.rm.xtext.module.Renaming
import org.cmg.tapas.rm.xtext.module.ElementRenaming
import org.cmg.tapas.rm.xtext.module.DeclarationRenaming
import org.cmg.tapas.rm.xtext.module.NamedElement
import org.cmg.tapas.rm.xtext.module.Action
import org.cmg.tapas.rm.xtext.module.RenameableElement
import org.cmg.tapas.rm.xtext.module.IntegerType

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ModuleValidator extends AbstractModuleValidator {
	
	public static String TYPE_ERROR = "TYPE_ERROR"
	
	public static String ILLEGAL_ACCESS_TO_LV = "ILLEGAL_ACCESS_TO_LV"
	
	public static String ILLEGAL_ACCESS_TO_GV = "ILLEGAL_ACCESS_TO_GV"

	public static String ILLEGAL_USE_OF_FUNCTION = "ILLEGAL_USE_OF_FUNCTION"

	public static String ILLEGAL_USE_OF_VARIABLE = "ILLEGAL_USE_OF_VARIABLE"

	public static String CIRCULAR_CONSTANT_DECLARATION = "CIRCULAR_CONSTANT_DECLARATION"

	public static String CIRCULAR_FUNCTION_DECLARATION = "CIRCULAR_FUNCTION_DECLARATION"
	
	public static String CIRCULAR_MODULE_RENAMING = "CIRCULAR_MODULE_RENAMING"
	
	public static String UNCOMPATIBLE_ACTION_RENAMING = "UNCOMPATIBLE_ACTION_RENAMING"

	public static String UNCOMPATIBLE_VARIABLE_RENAMING = "UNCOMPATIBLE_VARIABLE_RENAMING"
	
	public static String MISSING_RENAMING_OF_LOCAL_VARIABLE = "MISSING_RENAMING_OF_LOCAL_VARIABLE"
	
	public static String DUPLICATE_VARIABLE_RENAMING = "DUPLICATE_VARIABLE_RENAMING"
		
	@Inject
	TypeInference inference

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}


	@Check
	def dispatch checkOperatorsType( Plus e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.PLUS__LEFT , TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.PLUS__RIGHT , TYPE_ERROR )			
		}	
	}

	@Check
	def dispatch checkOperatorsType( Minus e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.MINUS__LEFT , TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.MINUS__RIGHT , TYPE_ERROR )			
		}	
	}

	@Check
	def dispatch checkOperatorsType( Multiplication e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.MULTIPLICATION__LEFT , TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.MULTIPLICATION__RIGHT , TYPE_ERROR )			
		}	
	}
	
	@Check
	def dispatch checkOperatorsType( Division e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.DIVISION__LEFT , TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.DIVISION__RIGHT , TYPE_ERROR )			
		}	
	}
	
	@Check
	def dispatch checkOperatorsType( Or e ) {
		if ( inference.inferType(e.left) != RMDataType::BOOL ) {
			error( 'Type error!' , ModulePackage.Literals.OR__LEFT , TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::BOOL ) {
			error( 'Type error!' , ModulePackage.Literals.OR__RIGHT , TYPE_ERROR )			
		}	
	}

	@Check
	def dispatch checkOperatorsType( And e ) {
		if ( inference.inferType(e.left) != RMDataType::BOOL ) {
			error( 'Type error!' , ModulePackage.Literals.AND__LEFT , TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::BOOL ) {
			error( 'Type error!' , ModulePackage.Literals.AND__RIGHT , TYPE_ERROR )			
		}	
	}
	
	@Check
	def dispatch checkOperatorsType( NotExpression e ) {
		if ( inference.inferType(e.arg) != RMDataType::BOOL ) {
			error( 'Type error!' , ModulePackage.Literals.NOT_EXPRESSION__ARG , TYPE_ERROR)			
		}
	}
	
	@Check
	def dispatch checkOperatorsType( Equal e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.EQUAL__LEFT, TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.EQUAL__RIGHT , TYPE_ERROR )			
		}	
	}

	@Check
	def dispatch checkOperatorsType( NotEqual e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.NOT_EQUAL__LEFT, TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.NOT_EQUAL__RIGHT , TYPE_ERROR )			
		}	
	}

	@Check
	def dispatch checkOperatorsType( LessEq e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.LESS_EQ__LEFT, TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.LESS_EQ__RIGHT , TYPE_ERROR )			
		}	
	}

	@Check
	def dispatch checkOperatorsType( GreaterEq e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.GREATER_EQ__LEFT, TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.GREATER_EQ__RIGHT , TYPE_ERROR )			
		}	
	}

	@Check
	def dispatch checkOperatorsType( Less e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.LESS__LEFT, TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.LESS__RIGHT , TYPE_ERROR )			
		}	
	}

	@Check
	def dispatch checkOperatorsType( Greater e ) {
		if ( inference.inferType(e.left) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.GREATER__LEFT, TYPE_ERROR)			
		}
		if ( inference.inferType(e.right) != RMDataType::INT ) {
			error( 'Type error!' , ModulePackage.Literals.GREATER__RIGHT , TYPE_ERROR )			
		}	
	}
	
	@Check
	def checkCommand( Command c ) {
		var mVariable = c.variable.getContainerOfType(typeof(Module))	
		if (mVariable != null) {
			var mCommand = c.getContainerOfType(typeof(Module))
			if (mVariable != mCommand) {
				error( 'Module '+mCommand.name+' cannot update variable '+c.variable.name+" defined in module "+mVariable.name+"!" , ModulePackage.Literals.COMMAND__VARIABLE , ILLEGAL_ACCESS_TO_LV )
			}
		} 
	}
	
	@Check
	def checkUpdateOfGlobalVariables( Command c ) {
		var mVariable = c.variable.getContainerOfType(typeof(Module))	
		if (mVariable == null) {
			var rule = c.getContainerOfType(typeof(Rule))
			if (rule.act != null) {
				error( 'Global variable '+c.variable.name+' cannot be updated in a named transition!' , ModulePackage.Literals.COMMAND__VARIABLE , ILLEGAL_ACCESS_TO_GV )
			}
		}
	}
	
	@Check
	def checkVariablesAndFunctionsInConstantDeclarations( LiteralExpression c ) {
		var cDeclaration = c.getContainerOfType(typeof(Constant)) 
		if (cDeclaration != null) {
			var n = c.reference
			switch n {
				Function:
					error( 'Functions cannot occur in constants declarations!' , ModulePackage.Literals.LITERAL_EXPRESSION__REFERENCE , ILLEGAL_USE_OF_FUNCTION )
				Variable:
					error( 'Variables cannot occur in constants declarations!' , ModulePackage.Literals.LITERAL_EXPRESSION__REFERENCE , ILLEGAL_USE_OF_VARIABLE )
			}
		}
	}
	
	@Check
	def checkVariablesAndFunctionsInTypeDeclarations( LiteralExpression c ) {
		var cDeclaration = c.getContainerOfType(typeof(IntegerType)) 
		if (cDeclaration != null) {
			var n = c.reference
			switch n {
				Function:
					error( 'Functions cannot occur in type declarations!' , ModulePackage.Literals.LITERAL_EXPRESSION__REFERENCE , ILLEGAL_USE_OF_FUNCTION )
				Variable:
					error( 'Variables cannot occur in type declarations!' , ModulePackage.Literals.LITERAL_EXPRESSION__REFERENCE , ILLEGAL_USE_OF_VARIABLE )
			}
		}
	}
	
	@Check
	def checkCircularConstantDefinition( Constant c ) {
		var cSet = c.expression.collectConstants( newHashSet(c) )
		if (cSet.contains(c)) {
			error( 'Circular definition of constant '+c.name+'!' , ModulePackage.Literals.CONSTANT__EXPRESSION , CIRCULAR_CONSTANT_DECLARATION )
		}
	}

	@Check
	def checkCircularFunctionDefinition( Function f ) {
		var cSet = f.body.collectFunctions( newHashSet(f) )
		if (cSet.contains(f)) {
			error( 'Circular definition of function '+f.name+'!' , ModulePackage.Literals.FUNCTION__BODY , CIRCULAR_FUNCTION_DECLARATION )
		}
	}
	
	@Check
	def checkCircularModuleRenaming( Module m ) {
		var mSet = m.moduleDependencies
		if (mSet.contains(m)) {
			error( 'Circular renaming of module '+m.name+'!' , ModulePackage.Literals.MODULE__NAME , CIRCULAR_MODULE_RENAMING )
		}
	}
	
	@Check
	def checkRenamingOf( ElementRenaming e ) {
		var module = e.getContainerOfType( Module )
		var renamedModule = e.getContainerOfType( DeclarationRenaming ).module
		var source = e.src
		switch source {
			Variable: 
				checkRenamingOfVariable( module , renamedModule , source , e.trg )
			Action: 
				checkRenamingOfAction( source , e.trg )
		}
	}


	def private checkRenamingOfVariable( Module context , Module renamedModule , Variable source , RenameableElement target ) {
		switch target {
			Action:
				error('Variable '+source.name+' cannot be renamed in action '+target.name+'!',ModulePackage.Literals.ELEMENT_RENAMING__TRG , UNCOMPATIBLE_VARIABLE_RENAMING )
			Variable: {
				var sourceModule = source.getContainerOfType(Module)
				var targetModule = target.getContainerOfType(Module)

				if ((sourceModule==null)&&(targetModule!=null)) {
					error('Global variable '+source.name+' cannot be renamed in the local variable '+target.name+'!', ModulePackage.Literals.ELEMENT_RENAMING__TRG, UNCOMPATIBLE_VARIABLE_RENAMING)					
				} 	
				if ((sourceModule!=null)&&(targetModule==null)) {			
					error('Local variable '+source.name+' cannot be renamed in the global variable '+target.name+'!', ModulePackage.Literals.ELEMENT_RENAMING__TRG, UNCOMPATIBLE_VARIABLE_RENAMING)					
				}
				
				if ((sourceModule == renamedModule)&&(targetModule != context)) {
					error('Local variable '+source.name+' of module '+renamedModule.name+'cannot be renamed in '+target.name+' that is an external variable of module '+context.name+'!', ModulePackage.Literals.ELEMENT_RENAMING__TRG, UNCOMPATIBLE_VARIABLE_RENAMING)					
				}
				if ((sourceModule != renamedModule)&&(targetModule == context)) {
					error('External variable '+source.name+' of module '+renamedModule.name+'cannot be renamed in '+target.name+' that is a local variable of module '+context.name+'!', ModulePackage.Literals.ELEMENT_RENAMING__TRG, UNCOMPATIBLE_VARIABLE_RENAMING)					
				}
				
			}		
				
		}
	}	
	
	
	def private checkRenamingOfAction( Action source , RenameableElement target ) {
		switch target {
			Variable: 
				error('Action '+source.name+' cannot be renamed in the variable '+target+'!', ModulePackage.Literals.ELEMENT_RENAMING__TRG , UNCOMPATIBLE_ACTION_RENAMING )
		}
	}

	@Check
	def checkRenamingOfAllLocalVariables( Module m ) {
		val body = m.body
		switch body {
			DeclarationRenaming: {
				var module = body.module
				var notRenamed = module.variables.filter[ v | body.renaming.forall[ r | r.src != v ] ]	
				if (notRenamed.length > 0) {
					var message = 'Local '+if (notRenamed.length==1) { 'Variable '} else {'Variables '}
					message = message+notRenamed.map[v | v.name ].join(''', ''')+' of module '+module.name
					message = message+if (notRenamed.length==1) { ' is'} else {' are'}
					message = message+' not renamed!'
					error( message , ModulePackage.Literals.MODULE__BODY , MISSING_RENAMING_OF_LOCAL_VARIABLE )					
				}
			}				
		}
	}
	
	@Check
	def checkIniettiveRenaming( ElementRenaming r ) {
		var trg = r.trg
		switch (trg) {
			Variable: {
				val duplicate = r.getContainerOfType(DeclarationRenaming).renaming.findFirst[ it != r && it.trg == r.trg ]
				if (duplicate != null) {
					error( 'Renaming function must to be injective!', ModulePackage.Literals.ELEMENT_RENAMING__TRG , DUPLICATE_VARIABLE_RENAMING )					
				}			
			}
		}
	}
}
