/*
 * generated by Xtext
 */
package org.cmg.tapas.rm.xtext.generator

import org.cmg.tapas.rm.xtext.module.Action
import org.cmg.tapas.rm.xtext.module.And
import org.cmg.tapas.rm.xtext.module.Constant
import org.cmg.tapas.rm.xtext.module.Division
import org.cmg.tapas.rm.xtext.module.Equal
import org.cmg.tapas.rm.xtext.module.Expression
import org.cmg.tapas.rm.xtext.module.FalseExpression
import org.cmg.tapas.rm.xtext.module.Function
import org.cmg.tapas.rm.xtext.module.Greater
import org.cmg.tapas.rm.xtext.module.GreaterEq
import org.cmg.tapas.rm.xtext.module.Less
import org.cmg.tapas.rm.xtext.module.LessEq
import org.cmg.tapas.rm.xtext.module.LiteralExpression
import org.cmg.tapas.rm.xtext.module.Minus
import org.cmg.tapas.rm.xtext.module.Model
import org.cmg.tapas.rm.xtext.module.Multiplication
import org.cmg.tapas.rm.xtext.module.NotEqual
import org.cmg.tapas.rm.xtext.module.NotExpression
import org.cmg.tapas.rm.xtext.module.NumberExpression
import org.cmg.tapas.rm.xtext.module.Or
import org.cmg.tapas.rm.xtext.module.Plus
import org.cmg.tapas.rm.xtext.module.TrueExpression
import org.cmg.tapas.rm.xtext.module.Variable
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.util.Wrapper
import org.cmg.tapas.rm.xtext.module.VariableType
import org.cmg.tapas.rm.xtext.module.BooleanType
import org.cmg.tapas.rm.xtext.module.IntegerType
import org.cmg.tapas.rm.xtext.module.Rules
import org.cmg.tapas.rm.xtext.module.DeclarationRenaming
import java.util.List
import org.cmg.tapas.rm.xtext.module.Module
import org.cmg.tapas.rm.xtext.module.RenameableElement
import org.cmg.tapas.rm.xtext.module.Rule
import com.google.inject.Inject
import org.cmg.tapas.rm.xtext.validation.TypeInference
import org.cmg.tapas.rm.xtext.validation.RMDataType
import org.cmg.tapas.rm.xtext.module.Skip
import org.cmg.tapas.rm.xtext.module.Commands
import org.cmg.tapas.rm.xtext.module.Synchronization
import org.cmg.tapas.rm.xtext.module.ModuleStructure
import org.cmg.tapas.rm.xtext.module.Cooperation
import org.cmg.tapas.rm.xtext.module.Interleaving
import org.cmg.tapas.rm.xtext.module.Hiding
import org.cmg.tapas.rm.xtext.module.Renaming
import org.cmg.tapas.rm.xtext.module.ModuleReference

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ModuleGenerator implements IGenerator {
	
	static String referenceToCurrentState = "_state_";

	static String referenceToNextState = "_next_state_";
	
	static String stateEnumeratorName = "STATE_ENUMERATOR"
	
	static String moduleFactoryName = "MODULE_FACTORY"
	
	@Inject
	TypeInference inference;
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))
		for (m: resource.allContents.toIterable.filter(Model)) {
			fsa.generateFile(
				"models/"+m.specification+".java",
				m.compile
			)
		}
	}
	
	def compile( Model m ) {
		var vTable = m.variables.generateIndexes

		'''
		package models;
		
		import org.cmg.tapas.rm.runtime.*;
		
		public class «m.specification» extends RMSpecification {
			
			«FOR c:m.constants» 
			public static int «c.name.nameOfConstant» = «c.expression.generate(null)»;
			«ENDFOR»
			
			«FOR v:vTable»
			public static int «v.key.name.nameOfVariable» = «v.value»;
			«ENDFOR»
			
			«FOR macro:m.functions»
			public static «inference.inferType(macro.body).declarationType» «macro.name.nameOfMacro»( State «referenceToCurrentState» ) {
				return «macro.body.generate( null )»;	
			}			
			«ENDFOR»
			
			public static StateEnumerator «stateEnumeratorName» = StateEnumerator.createEnumerator(
				new int[] {
					«FOR v:vTable SEPARATOR ','»
					«v.key.type.typeLowerBound»
					«ENDFOR»
				} , 
				new int[] {
					«FOR v:vTable SEPARATOR ','»
					«v.key.type.typeUpperBound»
					«ENDFOR»
				}
			);
			
			
			«FOR a:m.actions.map[ actions ].flatten»
			public static ModuleAction «a.name.nameOfAction» = new ModuleAction( "«a.name»" );
			«ENDFOR»

			public static ModuleFactory «moduleFactoryName» = new ModuleFactory( 
				«stateEnumeratorName» «IF m.actions.length>0»,«ENDIF»
				«FOR a:m.actions.map[ actions ].flatten SEPARATOR ','»«a.name.nameOfAction»«ENDFOR»
			);

			public static ModuleAction «tauAction()» = «moduleFactoryName».getTauAction();

			«FOR module:m.modules»
			public static ModuleFactory.ReactiveModule «module.name.nameOfModule» = «module.generateModuleCreationCode»
			«ENDFOR»
			
			«FOR system:m.systems»
			public static ModuleFactory.ReactiveModule «system.name.nameOfModule» = «system.system.generateSystemCode(system.name)»;
			«ENDFOR»
			
			public «m.specification»() {
				super( 
					new String[] {
							«FOR v:vTable SEPARATOR ','»
							"«v.key.name»"
							«ENDFOR»
					} , 
					«stateEnumeratorName»
				);	
			}
			
			
			public AbstractReactiveModule getSystem( String name ) {
				«FOR s:m.systems»
				if ("«s.name»".equals( name ) ) {
					return «s.name.nameOfModule»;	
				}
				«ENDFOR»
				return null;	
			}
			
			public int getValueOf( String constant ) {
				«FOR c:m.constants»
				if (constant.equals("«c.name»")) {
					return «c.name.nameOfConstant»;
				}				
				«ENDFOR»
				return 0;
			}

			public int getIndexOf( String variable ) {
				«FOR v:vTable»
				if (variable.equals("«v.key.name»")) {
					return «v.key.name.nameOfVariable»;
				}				
				«ENDFOR»
				return -1;
			}
			
			public String[] getSystems() {
				return new String[] { «FOR s:m.systems.map[ name ].sort SEPARATOR ','»"«s»"«ENDFOR»};	
			}
			
		}
		'''
	}
	
	
	def generateActionFactoryCode( ) {
		
	}
	
	def getTypeLowerBound( VariableType t ) {
		switch t {
			BooleanType: '''0'''
			IntegerType: t.start.generate( null )
		}
	}

	def getTypeUpperBound( VariableType t ) {
		switch t {
			BooleanType: '''1'''
			IntegerType: t.end.generate( null )
		}
	}
	
	def getVariables( Model m ) {
		m.globalVariables.map[ variable ] + m.modules.map[ variables ].flatten
	}
	
	def <T> generateIndexes( Iterable<T> list ) {
		val i = Wrapper::wrap(0)
		list.map[ v | 
			var c = i.get
			i.set(c+1)
			v -> c
		]
	}
	
	def nameOfConstant( String name ) {
		'''_CONST_«name»'''
	}
	
	def nameOfVariable( String name ) {
		'''_VAR_«name»'''
	}

	def nameOfMacro( String name ) {
		'''_MACRO_«name»'''
	}
	
	def nameOfAction( String name ) {
		'''_ACT_«name»'''
	}

	def nameOfModule( String name ) {
		'''_MOD_«name»'''
	}
	
	def dispatch CharSequence generate( Expression e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''0'''
	}
	
	def dispatch CharSequence generate( Or e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») || («e.right.generate(context)»)'''
	}
	
	def dispatch CharSequence generate( And e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») && («e.right.generate(context)»)'''
	}
	
	def dispatch CharSequence generate( Equal e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») == («e.right.generate(context)»)'''
	}

	def dispatch CharSequence generate( Less e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») < («e.right.generate(context)»)'''
	}
	
	def dispatch CharSequence generate( LessEq e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») <= («e.right.generate(context)»)'''
	}
	
	def dispatch CharSequence generate( GreaterEq e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») >= («e.right.generate(context)»)'''
	}

	def dispatch CharSequence generate( Greater e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») > («e.right.generate(context)»)'''
	}
	
	def dispatch CharSequence generate( NotEqual e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») != («e.right.generate(context)»)'''
	}

	def dispatch CharSequence generate( Plus e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») + («e.right.generate(context)»)'''
	}
	
	def dispatch CharSequence generate( Minus e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») - («e.right.generate(context)»)'''
	}
	
	def dispatch CharSequence generate( Multiplication e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») + («e.right.generate(context)»)'''
	}
	
	def dispatch CharSequence generate( Division e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''(«e.left.generate(context)») + («e.right.generate(context)»)'''
	}
	
	def dispatch CharSequence generate( TrueExpression e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''true'''
	}
	
	def dispatch CharSequence generate( FalseExpression e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''false'''
	}
	
	def dispatch CharSequence generate( NotExpression e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''!( «e.arg.generate(context)» )'''
	}
	
	def dispatch CharSequence generate( NumberExpression e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''«e.number»'''
	}
	
	def dispatch CharSequence generate( LiteralExpression e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		var ref = e.reference
		switch ref {
			Constant: ref.name.nameOfConstant
			Variable: {
				var v = (context?.apply( ref ) ?: ref) as Variable
				v.generateAccessToVariableCode
			}
			Function: '''«ref.name.nameOfMacro»( «referenceToCurrentState» )'''
			Action: {
				var v = (context?.apply( ref ) ?: ref) as Action
				v.name.nameOfAction
			}
		}
	}
	
	def generateAccessToVariableCode( Variable v ) {
		var code = '''«stateEnumeratorName».get( «referenceToCurrentState» , «v.name.nameOfVariable» )'''
		if (inference.getType(v.type) == RMDataType::BOOL) {
			'''(«code» == 1)'''
		} else {
			code
		}
	}
	
	def generateWriteToVariableCode( Variable v , Expression e , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		var evalExpressionCode = e.generate(context)
		var v2 = (context?.apply( v ) ?: v) as Variable
		
		if (inference.getType(v.type)==RMDataType::BOOL) {
			'''«referenceToNextState» = «stateEnumeratorName».set( «referenceToNextState» , «v2.name.nameOfVariable» , («evalExpressionCode»?1:0) );'''
		} else {
			'''«referenceToNextState» = «stateEnumeratorName».set( «referenceToNextState» , «v2.name.nameOfVariable» , «evalExpressionCode» );'''
		}	
	}
	
	def generateModuleCreationCode( Module module ) {
		var statementList = module.body.generateStatements( null )
		'''
		«moduleFactoryName».createReactiveModule(
			"«module.name»" «IF statementList.length>0» , «ENDIF»
			«FOR s:statementList SEPARATOR ','»
			«s»
			«ENDFOR»			 				
		);
		'''
	}
	
	def dispatch List<CharSequence> generateStatements( Rules body , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		body.rules.map[ generateStatement( context ) ]
	}
	
	def generateStatement( Rule r , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		'''
		new Statement( 
			«IF r.act!=null»«r.act.name.nameOfAction»«ELSE»«tauAction»«ENDIF» ,
			new Guard() {
			
				public boolean eval( State «referenceToCurrentState» ) {
					return «r.guard.generate( context )»;
				}				
			} ,
			new Command() {
				
				protected int apply( State «referenceToCurrentState» , int «referenceToNextState» ) {
					«r.command.generateStateUpdateCode( context )»
					return «referenceToNextState»;				
				}				
			}
		)		
		'''
	}
	
	def dispatch generateStateUpdateCode( Skip cmd , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		''''''
	}
	
	def dispatch generateStateUpdateCode( Commands cmd , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		cmd.commands.map[ variable.generateWriteToVariableCode( expression , context )].join("\n ")
	}
	
	
	def dispatch List<CharSequence> generateStatements( DeclarationRenaming body , Iterable<Pair<RenameableElement,RenameableElement>> context ) {
		body.module.body.generateStatements( body.renaming.map[ src -> trg ].combine( context ))
	}
	
	def tauAction( ) {
		"TAU".nameOfAction
	}

	def RenameableElement apply(Iterable<Pair<RenameableElement,RenameableElement>> f ,  RenameableElement element ) {
		var result = f?.findFirst[ key == element ]?.value
		if (result == null) {
			element
		} else {
			result
		}
	}
	
	def combine( Iterable<Pair<RenameableElement,RenameableElement>> f , Iterable<Pair<RenameableElement,RenameableElement>> g ) {
		if ( g == null) {
			f
		} else {
			var f1 = (f.map[ key -> g.apply( value ) ]) 
			val f2 = (g.filter[ cg | f.forall[ cf | cg.key != cf.key ] ]) 
			f1+f2
		}
	}
	
	def getDeclarationType( RMDataType type ) {
		switch type {
			case RMDataType::BOOL: '''boolean'''
			case RMDataType::INT: '''int'''
			case RMDataType::ERROR: '''Object'''
		}
	}

	def dispatch CharSequence generateSystemCode( ModuleStructure structure , String name ) {
		'''null'''
	}

	def dispatch CharSequence generateSystemCode( Synchronization structure , String name ) {
		'''
		«moduleFactoryName».synchronization( «IF name != null»"«name»" , «ENDIF» 
			«structure.left.generateSystemCode(null)» , 
			«structure.right.generateSystemCode(null)»
		)
		'''
	}

	def dispatch CharSequence generateSystemCode( Interleaving structure , String name ) {
		'''
		«moduleFactoryName».interleaving( «IF name != null»"«name»" , «ENDIF» 
			«structure.left.generateSystemCode(null)» , 
			«structure.right.generateSystemCode(null)»
		)
		'''
	}

	def dispatch CharSequence generateSystemCode( Cooperation structure , String name ) {
		'''
		«moduleFactoryName».cooperation( «IF name != null»"«name»" , «ENDIF» 
			«structure.left.generateSystemCode(null)» , 
			«structure.right.generateSystemCode(null)» «IF structure.actions.length>0»,«ENDIF»
			«FOR act:structure.actions SEPARATOR ','»«act.name.nameOfAction»«ENDFOR»
		)
		'''
	}

	def dispatch CharSequence generateSystemCode( Hiding structure , String name ) {
		'''
		«moduleFactoryName».hide( «IF name != null»"«name»" , «ENDIF» 
			«structure.module.generateSystemCode(null)» «IF structure.actions.length>0»,«ENDIF»
			«FOR act:structure.actions SEPARATOR ','»«act.name.nameOfAction»«ENDFOR»)
		)
		'''
	}

	def dispatch CharSequence generateSystemCode( Renaming structure , String name ) {
		'''
		«moduleFactoryName».cooperation( «IF name != null»"«name»" , «ENDIF» 
			«structure.module.generateSystemCode(null)» ,
			new ModuleAction[] { «FOR r:structure.renaming SEPARATOR ','»«r.src.name.nameOfAction»«ENDFOR» } ,
			new ModuleAction[] { «FOR r:structure.renaming SEPARATOR ','»«r.trg.name.nameOfAction»«ENDFOR» }
		)
		'''
	}

	def dispatch CharSequence generateSystemCode( ModuleReference reference , String name ) {
		reference.module.name.nameOfModule
	}

	/*
RestrictedRenamedModule returns ModuleStructure:
	BasicModule ( 
		{Hiding.module=current} '/{' (actions+=[Action] (',' actions+=[Action] )*)? '}'
		| {Renaming.module=current} '[' (renaming += ActionRenaming (',' renaming+=ActionRenaming)* )? ']'
	)?
;

ActionRenaming:
	src=[Action] '->' trg=[Action]
;

BasicModule returns ModuleStructure:
	'(' ModuleStructure ')'
	| ModuleReference
;

ModuleReference:
	module=[Module]
;	 * 
	 */

}
