/*
 * generated by Xtext
 */
package org.cmg.tapas.xtext.clts.generator

import org.cmg.tapas.TAPAsProjectHelper
import org.cmg.tapas.xtext.clts.composedLts.ActionLabelPredicate
import org.cmg.tapas.xtext.clts.composedLts.AnyLabelPredicate
import org.cmg.tapas.xtext.clts.composedLts.CapLabelPredicate
import org.cmg.tapas.xtext.clts.composedLts.CupLabelPredicate
import org.cmg.tapas.xtext.clts.composedLts.HmlAndFormula
import org.cmg.tapas.xtext.clts.composedLts.HmlBoxFormula
import org.cmg.tapas.xtext.clts.composedLts.HmlDiamondFormula
import org.cmg.tapas.xtext.clts.composedLts.HmlFalse
import org.cmg.tapas.xtext.clts.composedLts.HmlFormula
import org.cmg.tapas.xtext.clts.composedLts.HmlFormulaDeclaration
import org.cmg.tapas.xtext.clts.composedLts.HmlMaxFixPoint
import org.cmg.tapas.xtext.clts.composedLts.HmlMinFixPoint
import org.cmg.tapas.xtext.clts.composedLts.HmlNotFormula
import org.cmg.tapas.xtext.clts.composedLts.HmlOrFormula
import org.cmg.tapas.xtext.clts.composedLts.HmlPredicate
import org.cmg.tapas.xtext.clts.composedLts.HmlRecursionVariable
import org.cmg.tapas.xtext.clts.composedLts.HmlTrue
import org.cmg.tapas.xtext.clts.composedLts.LabelPredicate
import org.cmg.tapas.xtext.clts.composedLts.LtlAlwaysFormula
import org.cmg.tapas.xtext.clts.composedLts.LtlAndFormula
import org.cmg.tapas.xtext.clts.composedLts.LtlAtomicProposition
import org.cmg.tapas.xtext.clts.composedLts.LtlEventuallyFormula
import org.cmg.tapas.xtext.clts.composedLts.LtlFalse
import org.cmg.tapas.xtext.clts.composedLts.LtlFormula
import org.cmg.tapas.xtext.clts.composedLts.LtlFormulaDeclaration
import org.cmg.tapas.xtext.clts.composedLts.LtlNextFormula
import org.cmg.tapas.xtext.clts.composedLts.LtlNotFormula
import org.cmg.tapas.xtext.clts.composedLts.LtlOrFormula
import org.cmg.tapas.xtext.clts.composedLts.LtlTrue
import org.cmg.tapas.xtext.clts.composedLts.LtlUntilFormula
import org.cmg.tapas.xtext.clts.composedLts.Lts
import org.cmg.tapas.xtext.clts.composedLts.LtsComposition
import org.cmg.tapas.xtext.clts.composedLts.LtsDeclarationBody
import org.cmg.tapas.xtext.clts.composedLts.Model
import org.cmg.tapas.xtext.clts.composedLts.NotLabelPredicate
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.cmg.tapas.xtext.clts.composedLts.Action
import org.eclipse.emf.common.util.EList
import java.util.LinkedList
import org.cmg.tapas.xtext.clts.composedLts.Interleaving
import org.cmg.tapas.xtext.clts.composedLts.Synchronization
import org.cmg.tapas.xtext.clts.composedLts.ControlledInteraction
import org.cmg.tapas.xtext.clts.composedLts.CompositionBody
import org.cmg.tapas.xtext.clts.composedLts.Reference
import org.cmg.tapas.xtext.clts.composedLts.Renaming

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ComposedLtsGenerator implements IGenerator {
	
	var stateCounter = 0;
	var LinkedList<Action> allAct;
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for( m: resource.allContents.toIterable.filter(typeof(Model)) ) {
			println(resource.URI)
			print("Is relative: ")
			println(resource.URI.relative)
			print("Is file: ")
			println(resource.URI.file)
			print("Is hierarchical: ")
			println(resource.URI.hierarchical)
			print("Path: ")
			println(resource.URI.path)
			print("Is platform: ")
			println(resource.URI.platform)
			print("To platform (true): ")
			println(resource.URI.toPlatformString(true))
			print("To platform (false): ")
			println(resource.URI.toPlatformString(false))
			print("Package folder: ")
			println(TAPAsProjectHelper.getPackageFolder(resource))
			fsa.generateFile(
				TAPAsProjectHelper.getPackageFolder(resource)+"/"+m.name+".java",
				m.generateSpecificationClass(
					TAPAsProjectHelper.getPackageFolder(resource).replace('/','.')
				)
			);			
		}
		
	}
	
	def generateSpecificationClass( Model m , String pack ) {
		allAct = new LinkedList<Action>();
		for(a:m.elements.filter(typeof(Action))){
			allAct.add(a)	
		}
		
		'''
		package «pack»;
		
		import org.cmg.tapas.core.util.*;
		import org.cmg.tapas.formulae.actl.*;
		import org.cmg.tapas.formulae.actl.path.*;
		import org.cmg.tapas.formulae.actl.state.*;
		import org.cmg.tapas.clts.runtime.*;
		import org.cmg.tapas.formulae.ltl.*;
		import org.cmg.tapas.formulae.ltl.LtlFormula.Atomic;
		import org.cmg.tapas.formulae.hml.*;
		import org.cmg.tapas.formulae.hml.HmlAtomic;
		import org.cmg.tapas.core.graph.filter.*;
		import java.util.*;
		
		public class «m.name» extends CltsModule {
				protected void initActions() {
				«FOR a:m.elements.filter(typeof(Action))»
				addAction( new CltsAction( "«a.name»" ) );
				«ENDFOR»
			}
			
			protected void initFormulae() {
				«FOR f:m.elements.filter(typeof(HmlFormulaDeclaration))»
				addFormula( "«f.name»" , generate_HMLFORMULA_«f.name»() );
				«ENDFOR»
				«FOR f:m.elements.filter(typeof(LtlFormulaDeclaration))»
				addFormula( "«f.name»" , generate_LTLFORMULA_«f.name»() );
				«ENDFOR»
			}
			
			«FOR f:m.elements.filter(typeof(HmlFormulaDeclaration))»
			«f.formulaDeclaration»	
			«ENDFOR»
			
			«FOR f:m.elements.filter(typeof(LtlFormulaDeclaration))»
			«f.formulaDeclaration»	
			«ENDFOR»
			
			protected void initStateSpace() {
				«FOR l : m.elements.filter(typeof(Lts))»
				«IF l.body instanceof LtsDeclarationBody»
					addLtsToLtsList("«l.name»");
					«var ltsBody = l.body as LtsDeclarationBody»
					«FOR s : ltsBody.states»
					CltsState _S_«l.name»_«s.name» = new CltsState("«s.name»" , "«l.name»",«stateId»);
					addState( _S_«l.name»_«s.name»);
					«ENDFOR»
					«FOR r : ltsBody.rules»
					ltsList.get("«l.name»").get("«r.src.name»").addNext(new CltsAction("«r.act.name»") ,
																		ltsList.get("«l.name»").get("«r.trg.name»"));
					«ENDFOR»
					«FOR la : ltsBody.labels»
					addLabel("«la.label.name»", "«l.name»", «FOR s:la.states SEPARATOR ','» "«s.name»" «ENDFOR»);
					«ENDFOR»
				«ENDIF»
				«IF l.body instanceof LtsComposition»
					«var b = l.body as LtsComposition»
					CltsProcess _SYS_«l.name» = «getLtsCode(b.body , l.name)»;
					addSystem("«l.name»" , _SYS_«l.name»);
				«ENDIF»
				«ENDFOR»
				}
											
		}
				
		'''	
	}
	
	def getStateId() {
		stateCounter = stateCounter+1;
		stateCounter
	}
	
	def dispatch CharSequence getLtsCode( Lts l , String ltsName){
		getLtsCode( l.body , l.name);
	}
	
	def dispatch CharSequence getLtsCode( LtsComposition l, String ltsName ){
		getLtsCode( l.body , ltsName);	
	}
	
	def dispatch CharSequence getLtsCode( LtsDeclarationBody l , String ltsName){
		'''
		ltsList.get("«ltsName»").get("«l.init.findFirst[true].name»")
		'''
	}
	
	def dispatch CharSequence getLtsCode( Renaming l, String ltsName ){
		'''
		new CltsRenaming(
			«l.arg.getLtsCode(ltsName)»,
			new CltsAction[] { «FOR m:l.maps SEPARATOR ','» new CltsAction("«m.src.name»") «ENDFOR»} ,
			new CltsAction[] { «FOR m:l.maps SEPARATOR ','» new CltsAction("«m.trg.name»") «ENDFOR»} 
			
		)
		'''
	}
	
	def dispatch CharSequence getLtsCode( Interleaving l , String ltsName){
		'''
		new CltsInterleaving(
					«this.getLtsCode( l.left , ltsName)»,
					«this.getLtsCode( l.right , ltsName)»
				)
		'''
	}
	
	def dispatch CharSequence getLtsCode( Synchronization l , String ltsName){
		'''
		new CltsCooperation(
			«getLtsCode( l.left , ltsName)»,
			«allActionFilter»,
			«getLtsCode( l.right , ltsName)»
		)
		'''
	}
	
	def dispatch CharSequence getLtsCode( ControlledInteraction l , String ltsName){
		'''
		new CltsCooperation(
			«getLtsCode( l.left , ltsName)»,
			«l.action.actionFilter»,
			«getLtsCode( l.right , ltsName)»
		)
		'''
	}
	
	def dispatch CharSequence getLtsCode( Reference l , String ltsName){
		'''
		«l.lts.getLtsCode(ltsName)»
		'''
	}
	
	def getActionFilter( EList<Action> actions){
		'''
			new CltsCooperationSet(«FOR a:actions SEPARATOR ","» new CltsAction("«a.name»")«ENDFOR»)	
		'''
	}
	
	def getAllActionFilter(){
		'''
			new CltsCooperationSet(«FOR a: allAct SEPARATOR ","» new CltsAction("«a.name»")«ENDFOR»)	
		'''
	}
	
	def getFormulaDeclaration( LtlFormulaDeclaration formula ) {
		'''

		protected LtlFormula<CltsProcess> generate_LTLFORMULA_«formula.name»() {
				return «formula.formula.generateLtlFormulaeCode»;
		}
		
		'''		
	}
	
	def CharSequence generateLtlFormulaeCode( LtlFormula f ) {
		switch f{
			LtlOrFormula : {
				'''
				new LtlFormula.Or<CltsProcess>(
				«f.left.generateLtlFormulaeCode» ,
				«f.right.generateLtlFormulaeCode»
				)
				'''
			}
			LtlAndFormula : {
				'''
				new LtlFormula.And<CltsProcess>(
				«f.left.generateLtlFormulaeCode» ,
				«f.right.generateLtlFormulaeCode»
				)
				'''
			}
			LtlUntilFormula : {
				'''
				new LtlFormula.Until<CltsProcess>(
				«f.left.generateLtlFormulaeCode» ,
				«f.right.generateLtlFormulaeCode»
				)
				'''
			}
			LtlNextFormula : {
				'''
				new LtlFormula.Next<CltsProcess>(
				«f.arg.generateLtlFormulaeCode»
				)
				'''
			}
			LtlAlwaysFormula : {
				'''
				new LtlFormula.Not<CltsProcess>(
					new LtlFormula.Until<CltsProcess>(
					new LtlFormula.True<CltsProcess>() , 
					new LtlFormula.Not<CltsProcess>(«f.arg.generateLtlFormulaeCode»))
					)
				'''
			}
			LtlEventuallyFormula : {
				'''
				new LtlFormula.Until<CltsProcess>(
					new LtlFormula.True<CltsProcess>() , «f.arg.generateLtlFormulaeCode»)
				'''
			}
			LtlNotFormula : {
				'''
				new LtlFormula.Not<CltsProcess>(
				«f.arg.generateLtlFormulaeCode»
				)
				'''
			}
			LtlTrue : ''' new LtlFormula.True<CltsProcess>()'''
			LtlFalse : ''' new LtlFormula.False<CltsProcess>()'''
			LtlAtomicProposition:'''new LtlFormula.Atomic<CltsProcess>("«f.prop.name»" , getLabel("«f.prop.name»"))'''
			default:
				'''new LtlFormula.False<CltsProcess>()'''
		}
	}
	
		def getFormulaDeclaration( HmlFormulaDeclaration formula ) {
		'''

		protected HmlFormula<CltsProcess,CltsAction> generate_HMLFORMULA_«formula.name»() {
				«formula.formula.generateDeclarationsOfRecursiveFormulae»				
				«formula.formula.generatePopulationOfRecursiveFormulae»
				return «formula.formula.generateHmlFormulaeCode»;
		}
		
		'''		
	}
	
	def CharSequence generateDeclarationsOfRecursiveFormulae( HmlFormula f ) {
		switch f {
			HmlOrFormula: {
				'''
				«f.left.generateDeclarationsOfRecursiveFormulae»
				«f.right.generateDeclarationsOfRecursiveFormulae»
				'''
			}
			HmlAndFormula: {
				'''
				«f.left.generateDeclarationsOfRecursiveFormulae»
				«f.right.generateDeclarationsOfRecursiveFormulae»
				'''
			}
			HmlNotFormula: {
				f.arg.generateDeclarationsOfRecursiveFormulae
			}
			HmlDiamondFormula:
				f.arg.generateDeclarationsOfRecursiveFormulae
			HmlBoxFormula:
				f.arg.generateDeclarationsOfRecursiveFormulae
			HmlMinFixPoint:
				'''
				HmlFixPoint<CltsProcess, CltsAction> _FIX_«f.name» = new HmlFixPoint<CltsProcess, CltsAction>(false, "«f.name»");
				'''
			HmlMaxFixPoint:
				'''
				HmlFixPoint<CltsProcess, CltsAction> _FIX_«f.name» = new HmlFixPoint<CltsProcess, CltsAction>(true, "«f.name»");
				'''
			HmlTrue: ''''''
			HmlFalse: ''''''
			HmlPredicate: ''''''
			default:
				''''''
		}
	}
	
	def CharSequence generatePopulationOfRecursiveFormulae( HmlFormula f ) {
		switch f {
			HmlOrFormula: {
				'''
				«f.left.generatePopulationOfRecursiveFormulae»
				«f.right.generatePopulationOfRecursiveFormulae»
				'''
			}
			HmlAndFormula: {
				'''
				«f.left.generatePopulationOfRecursiveFormulae»
				«f.right.generatePopulationOfRecursiveFormulae»
				'''
			}
			HmlNotFormula: {
				f.arg.generatePopulationOfRecursiveFormulae
			}
			HmlDiamondFormula:
				f.arg.generatePopulationOfRecursiveFormulae
			HmlBoxFormula:
				f.arg.generatePopulationOfRecursiveFormulae
			HmlMinFixPoint:
				'''
				_FIX_«f.name».setSubformula( «f.arg.generateHmlFormulaeCode»); 
				«f.arg.generatePopulationOfRecursiveFormulae»
				'''
			HmlMaxFixPoint:
				'''
				_FIX_«f.name».setSubformula( «f.arg.generateHmlFormulaeCode»); 
				«f.arg.generatePopulationOfRecursiveFormulae»
				'''
			HmlTrue: ''''''
			HmlFalse: ''''''
			default:
				''''''
		}
	}
	
	def CharSequence generateHmlFormulaeCode( HmlFormula f ) {
		switch f {
			HmlOrFormula: {
				'''
				new HmlOrFormula<CltsProcess, CltsAction>( 
					«f.left.generateHmlFormulaeCode» , 
					«f.right.generateHmlFormulaeCode»  
				)
				'''
			}
			HmlAndFormula: {
				'''
				new HmlAndFormula<CltsProcess, CltsAction>( 
					«f.left.generateHmlFormulaeCode» , 
					«f.right.generateHmlFormulaeCode»  
				)
				'''
			}
			HmlNotFormula: {
				'''
				new HmlNotFormula<CltsProcess, CltsActions>(
					«f.arg.generateHmlFormulaeCode»
				)
				'''
			}
			HmlDiamondFormula:
				'''
				new HmlDiamondFormula<CltsProcess,CltsAction>( 
						«f.action.generateFilterCode» , 
						«f.arg.generateHmlFormulaeCode»
				)
				'''
			HmlBoxFormula:
				'''
				new HmlBoxFormula<CltsProcess,CltsAction>( 
						«f.action.generateFilterCode» , 
						«f.arg.generateHmlFormulaeCode»
				)
				'''
			HmlMinFixPoint:
				'''
				_FIX_«f.name»
				'''
			HmlMaxFixPoint:
				'''
				_FIX_«f.name»
				'''
			HmlRecursionVariable:
				'''
				_FIX_«f.refeerence.name».getReference()
				'''
			HmlTrue: '''new HmlTrue<CltsProcess,CltsAction>()'''
			HmlFalse: '''new HmlFalse<CltsProcess,CltsAction>()'''
			HmlPredicate:'''new HmlAtomic<CltsProcess,CltsAction>(getLabel("«f.label.name»"))'''
			default:
				'''new HmlFalse<CltsProcess,CltsAction>()'''
		}
	}
	
	def CharSequence generateFilterCode( LabelPredicate pred ) {
		switch pred {
			CupLabelPredicate: 
				'''new OrFilter<CltsAction>( «pred.left.generateFilterCode» , «pred.righ.generateFilterCode»)'''	
			CapLabelPredicate:
				'''new AndFilter<CltsAction>( «pred.left.generateFilterCode» , «pred.right.generateFilterCode»)'''	
			NotLabelPredicate:
				'''new NotFilter<CltsAction>( «pred.arg.generateFilterCode» )'''	
			AnyLabelPredicate:
				'''new TrueFilter<CltsAction>() '''
			ActionLabelPredicate:
				'''new SingleActionFilter<CltsAction>( getAction("«pred.act.name»") )'''
			default:
				'''new FalseFilter<CltsAction>( )'''
		}
	}
}
